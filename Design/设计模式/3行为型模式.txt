行为型模式

这些设计模式特别关注对象之间的通信。
一、责任链模式（Chain of Responsibility Pattern）

1.定义：
责任链模式指的是：某个请求需要多个对象进行处理，从而避免请求的发送者和接收之间的耦合关系。将这些对象连成一条链子，并沿着这条链子传递该请求，直到有对象处理它为止。
从生活中的例子可以发现，某个请求可能需要几个人的审批，即使技术经理审批完了，还需要上一级的审批。
例如公司中的请假，少于3天的，直属Leader就可以批准，3天到7天之内就需要项目经理批准，多余7天的就需要技术总监的批准了。

2.角色：
从责任链模式的定义可以发现，责任链模式涉及的对象只有处理者角色，但由于有多个处理者，它们具有共同的处理请求的方法，所以这里抽象出一个抽象处理者角色进行代码复用。

抽象处理者角色（Handler）：定义出一个处理请求的接口。这个接口通常由接口或抽象类来实现。
具体处理者角色（ConcreteHandler）：具体处理者接受到请求后，可以选择将该请求处理掉，或者将请求传给下一个处理者。因此，每个具体处理者需要保存下一个处理者的引用，以便把请求传递下去。

3.适用场景:
一个系统的审批需要多个对象才能完成处理的情况下，例如请假系统等。
代码中存在多个if-else语句的情况下，此时可以考虑使用责任链模式来对代码进行重构。

4.优缺点
优点：
降低了请求的发送者和接收者之间的耦合。
把多个条件判定分散到各个处理类中，使得代码更加清晰，责任更加明确。

缺点：
在找到正确的处理对象之前，所有的条件判定都要执行一遍，当责任链过长时，可能会引起性能的问题。
可能导致某个请求不被处理。

参考：https://www.cnblogs.com/zhili/p/ChainOfResponsibity.html

二、命令模式（Command Pattern）

1.定义：
命令模式属于对象的行为型模式。命令模式是把一个操作或者行为抽象为一个对象，通过对命令的抽象化来使得发出命令的责任和执行命令的责任分隔开。命令模式的实现可以提供命令的撤销和恢复功能。

2.角色：
客户角色：发出一个具体的命令并确定其接受者。
命令角色：声明了一个给所有具体命令类实现的抽象接口
具体命令角色：定义了一个接受者和行为的弱耦合，负责调用接受者的相应方法。
请求者角色：负责调用命令对象执行命令。
接受者角色：负责具体行为的执行。

3.使用场景：

1）系统需要支持命令的撤销（undo）。命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时，可以调用undo方法吧命令所产生的效果撤销掉。
命令对象还可以提供redo方法，以供客户端在需要时，再重新实现命令效果。
2）系统需要在不同的时间指定请求、将请求排队。一个命令对象和原先的请求发出者可以有不同的生命周期。意思为：原来请求的发出者可能已经不存在了，而命令对象本身可能仍是活动的。
这时命令的接受者可以在本地，也可以在网络的另一个地址。命令对象可以串行地传送到接受者上去。
3）如果一个系统要将系统中所有的数据消息更新到日志里，以便在系统崩溃时，可以根据日志里读回所有数据的更新命令，重新调用方法来一条一条地执行这些命令，从而恢复系统在崩溃前所做的数据更新。
4）系统需要使用命令模式作为“CallBack(回调)”在面向对象系统中的替代。Callback即是先将一个方法注册上，然后再以后调用该方法。

4.优缺点：

优点：
命令模式使得新的命令很容易被加入到系统里。
可以设计一个命令队列来实现对请求的Undo和Redo操作。
可以较容易地将命令写入日志。
可以把命令对象聚合在一起，合成为合成命令。合成命令式合成模式的应用。

缺点：
使用命令模式可能会导致系统有过多的具体命令类。这会使得命令模式在这样的系统里变得不实际。

参考：https://www.cnblogs.com/zhili/p/CommandPattern.html

三、解释器模式（Interpreter Pattern）

1.定义：
解释器模式提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。
主要解决：对于一些固定文法构建一个解释句子的解释器。
应用实例：编译器、运算表达式计算。

2.使用场景： 
可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 
一些重复出现的问题可以用一种简单的语言来进行表达。 
一个简单语法需要解释的场景。

何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

3.代码结构
如何解决：构建语法树，定义终结符与非终结符。
关键代码：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。

4.优缺点:

优点： 
可扩展性比较好，灵活。 
增加了新的解释表达式的方式。 
易于实现简单文法。

缺点：
可利用场景比较少。 
对于复杂的文法比较难维护。 
解释器模式会引起类膨胀。 
解释器模式采用递归调用方法。

四、迭代器模式（Iterator Pattern）

1.定义：
迭代器是针对集合对象而生的，对于集合对象而言，必然涉及到集合元素的添加删除操作，同时也肯定支持遍历集合元素的操作，我们此时可以把遍历操作也放在集合对象中，
但这样的话，集合对象就承担太多的责任了，面向对象设计原则中有一条是单一职责原则，所以我们要尽可能地分离这些职责，用不同的类去承担不同的职责。迭代器模式就是用迭代器类来承担遍历集合元素的职责。

迭代器模式提供了一种方法顺序访问一个聚合对象（理解为集合对象）中各个元素，而又无需暴露该对象的内部表示，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。

2.角色：
迭代器角色（Iterator）：				迭代器角色负责定义访问和遍历元素的接口
具体迭代器角色（Concrete Iteraror）：	具体迭代器角色实现了迭代器接口，并需要记录遍历中的当前位置。
聚合角色（Aggregate）：					聚合角色负责定义获得迭代器角色的接口
具体聚合角色（Concrete Aggregate）：	具体聚合角色实现聚合角色接口

3.使用场景：
系统需要访问一个聚合对象的内容而无需暴露它的内部表示。
系统需要支持对聚合对象的多种遍历。
系统需要为不同的聚合结构提供一个统一的接口。

4.优缺点

优点：
迭代器模式使得访问一个聚合对象的内容而无需暴露它的内部表示，即迭代抽象。
迭代器模式为遍历不同的集合结构提供了一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作

缺点：
迭代器模式在遍历的同时更改迭代器所在的集合结构会导致出现异常。所以使用foreach语句只能在对集合进行遍历，不能在遍历的同时更改集合中的元素。

参考：https://www.cnblogs.com/zhili/p/IteratorPattern.html

五、中介者模式（Mediator Pattern）

1.定义：
从生活中的例子可以看出，不论是QQ游戏还是QQ群，它们都是充当一个中间平台，QQ用户可以登录这个中间平台与其他QQ用户进行交流，
如果没有这些中间平台，我们如果想与朋友进行聊天的话，可能就需要当面才可以了。电话、短信也同样是一个中间平台，有了这个中间平台，每个用户都不要直接依赖与其他用户，
只需要依赖这个中间平台就可以了，一切操作都由中间平台去分发。

中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。

2.角色：
抽象中介者角色：中介者类是起到协调各个对象的作用
具体中介者角色：则抽象中介者角色中则需要保存各个对象的引用
抽象同事类
具体同事类 

3.使用场景：
一组定义良好的对象，现在要进行复杂的相互通信。
想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。

4.优缺点：

优点：
简化了对象之间的关系，将系统的各个对象之间的相互关系进行封装，将各个同事类解耦，使得系统变为松耦合。
提供系统的灵活性，使得各个同事对象独立而易于复用。

缺点：
中介者模式中，中介者角色承担了较多的责任，所以一旦这个中介者对象出现了问题，整个系统将会受到重大的影响。例如，QQ游戏中计算欢乐豆的程序出错了，这样会造成重大的影响。
新增加一个同事类时，不得不去修改抽象中介者类和具体中介者类，此时可以使用观察者模式和状态模式来解决这个问题。

参考：https://www.cnblogs.com/zhili/p/MediatorPattern.html

六、备忘录模式（Memento Pattern）

1.定义：
从字面意思就可以明白，备忘录模式就是对某个类的状态进行保存下来，等到需要恢复的时候，可以从备忘录中进行恢复。如备忘电话通讯录，备份操作操作系统，备份数据库等。
备忘录模式的具体定义是：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以把该对象恢复到原先的状态。

2.角色：
发起人角色：记录当前时刻的内部状态，负责创建和恢复备忘录数据。
备忘录角色：负责存储发起人对象的内部状态，在进行恢复时提供给发起人需要的状态。
管理者角色：负责保存备忘录对象。

3.使用场景:
如果系统需要提供回滚操作时，使用备忘录模式非常合适。例如文本编辑器的Ctrl+Z撤销操作的实现，数据库中事务操作。

4.优缺点：

优点：
如果某个操作错误地破坏了数据的完整性，此时可以使用备忘录模式将数据恢复成原来正确的数据。
备份的状态数据保存在发起人角色之外，这样发起人就不需要对各个备份的状态进行管理。而是由备忘录角色进行管理，而备忘录角色又是由管理者角色管理，符合单一职责原则。

缺点：
在实际的系统中，可能需要维护多个备份，需要额外的资源，这样对资源的消耗比较严重。

参考：https://www.cnblogs.com/zhili/p/MementoPattern.html

七、观察者模式（Observer Pattern）

1.定义：
从生活中的例子可以看出，只要对订阅号进行关注的客户端，如果订阅号有什么更新，就会直接推送给订阅了的用户。从中，我们就可以得出观察者模式的定义。
观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己的行为。

2.角色：

抽象主题角色（Subject）：抽象主题把所有观察者对象的引用保存在一个列表中，并提供增加和删除观察者对象的操作，抽象主题角色又叫做抽象被观察者角色，一般由抽象类或接口实现。
抽象观察者角色（Observer）：为所有具体观察者定义一个接口，在得到主题通知时更新自己，一般由抽象类或接口实现。
具体主题角色（ConcreteSubject）：实现抽象主题接口，具体主题角色又叫做具体被观察者角色。
具体观察者角色（ConcreteObserver）：实现抽象观察者角色所要求的接口，以便使自身状态与主题的状态相协调。

使用事件和委托实现的观察者模式中，减少了订阅者接口类的定义，此时，.NET中的委托正式充到订阅者接口类的角色。使用委托和事件，确实简化了观察者模式的实现，减少了一个IObserver接口的定义

3.使用场景：
当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用的情况下。从方面的这个词中可以想到，观察者模式肯定在AOP（面向方面编程）中有所体现
当对一个对象的改变需要同时改变其他对象，而又不知道具体有多少对象有待改变的情况下。
当一个对象必须通知其他对象，而又不能假定其他对象是谁的情况下。

4.优缺点：

优点：
观察者模式实现了表示层和数据逻辑层的分离，并定义了稳定的更新消息传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层，即观察者。
观察者模式在被观察者和观察者之间建立了一个抽象的耦合，被观察者并不知道任何一个具体的观察者，只是保存着抽象观察者的列表，每个具体观察者都符合一个抽象观察者的接口。
观察者模式支持广播通信。被观察者会向所有的注册过的观察者发出通知。

缺点：
如果一个被观察者有很多直接和间接的观察者时，将所有的观察者都通知到会花费很多时间。
虽然观察者模式可以随时使观察者知道所观察的对象发送了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎样发生变化的。
如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃，在使用观察者模式应特别注意这点。

参考：https://www.cnblogs.com/zhili/p/ObserverPattern.html

八、状态模式（State Pattern）

1.定义：
每个对象都有其对应的状态，而每个状态又对应一些相应的行为，如果某个对象有多个状态时，那么就会对应很多的行为。
那么对这些状态的判断和根据状态完成的行为，就会导致多重条件语句，并且如果添加一种新的状态时，需要更改之前现有的代码。这样的设计显然违背了开闭原则。
状态模式正是用来解决这样的问题的。状态模式将每种状态对应的行为抽象出来成为单独新的对象，这样状态的变化不再依赖于对象内部的行为。

状态模式：允许一个对象在其内部状态改变时自动改变其行为，对象看起来就像是改变了它的类。

2.角色：
Account类：维护一个State类的一个实例，该实例标识着当前对象的状态。
State类：抽象状态类，定义了一个具体状态类需要实现的行为约定。
SilveStater、GoldState和RedState类：具体状态类，实现抽象状态类的每个行为。

3.应用场景：
当一个对象状态转换的条件表达式过于复杂时可以使用状态者模式。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简单化。
当一个对象行为取决于它的状态，并且它需要在运行时刻根据状态改变它的行为时，就可以考虑使用状态者模式。

4.优缺点：

优点：
将状态判断逻辑每个状态类里面，可以简化判断的逻辑。
当有新的状态出现时，可以通过添加新的状态类来进行扩展，扩展性好。

缺点：
如果状态过多的话，会导致有非常多的状态类，加大了开销。

参考：https://www.cnblogs.com/zhili/p/StatePattern.html

九、策略模式（Strategy Pattern）

1.定义：
在现实生活中，策略模式的例子也非常常见，
例如，中国的所得税，分为企业所得税、外商投资企业或外商企业所得税和个人所得税，针对于这3种所得税，针对每种，所计算的方式不同，个人所得税有个人所得税的计算方式，而企业所得税有其对应计算方式。
如果不采用策略模式来实现这样一个需求的话，可能我们会定义一个所得税类，该类有一个属性来标识所得税的类型，
并且有一个计算税收的CalculateTax()方法，在该方法体内需要对税收类型进行判断，通过if-else语句来针对不同的税收类型来计算其所得税。
这样的实现确实可以解决这个场景吗，但是这样的设计不利于扩展，如果系统后期需要增加一种所得税时，此时不得不回去修改CalculateTax方法来多添加一个判断语句，这样明白违背了“开放——封闭”原则。
此时，我们可以考虑使用策略模式来解决这个问题，既然税收方法是这个场景中的变化部分，此时自然可以想到对税收方法进行抽象。

策略模式是针对一组算法，将每个算法封装到具有公共接口的独立的类中，从而使它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。

2.角色：
环境角色（Context）：持有一个Strategy类的引用
抽象策略角色（Strategy）：这是一个抽象角色，通常由一个接口或抽象类来实现。此角色给出所有具体策略类所需实现的接口。
具体策略角色（ConcreteStrategy）：包装了相关算法或行为。

3.使用场景：
一个系统需要动态地在几种算法中选择一种的情况下。那么这些算法可以包装到一个个具体的算法类里面，并为这些具体的算法类提供一个统一的接口。
如果一个对象有很多的行为，如果不使用合适的模式，这些行为就只好使用多重的if-else语句来实现，
此时，可以使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句，并体现面向对象涉及的概念。

4.优缺点：

优点：
策略类之间可以自由切换。由于策略类都实现同一个接口，所以使它们之间可以自由切换。
易于扩展。增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码。
避免使用多重条件选择语句，充分体现面向对象设计思想。

缺点：
客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这点可以考虑使用IOC容器和依赖注入的方式来解决。
策略模式会造成很多的策略类。

参考：https://www.cnblogs.com/zhili/p/StragetyPattern.html

十、模板模式（Template Pattern）

1.定义：
模板方法模式——在一个抽象类中定义一个操作中的算法骨架（对应于生活中的大家下载的模板），而将一些步骤延迟到子类中去实现（对应于我们根据自己的情况向模板填充内容）。
模板方法使得子类可以不改变一个算法的结构前提下，重新定义算法的某些特定步骤，模板方法模式把不变行为搬到超类中，从而去除了子类中的重复代码。

2.角色：
抽象模板角色（Vegetable扮演这个角色）：定义了一个或多个抽象操作，以便让子类实现，这些抽象操作称为基本操作。
具体模板角色（ChineseCabbage和Spinach扮演这个角色）：实现父类所定义的一个或多个抽象方法。

3.优缺点：

优点：
实现了代码复用
能够灵活应对子步骤的变化，符合开放-封闭原则

缺点：
因为引入了一个抽象类，如果具体实现过多的话，需要用户或开发人员需要花更多的时间去理清类之间的关系。

参考：https://www.cnblogs.com/zhili/p/TemplateMethodPattern.html

十一、访问者模式（Visitor Pattern）

1.定义：
访问者模式是封装一些施加于某种数据结构之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保存不变。
访问者模式适用于数据结构相对稳定的系统， 它把数据结构和作用于数据结构之上的操作之间的耦合度降低，使得操作集合可以相对自由地改变。

数据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者对象则反过来执行节点对象的操作。这样的过程叫做“双重分派”。
节点调用访问者，将它自己传入，访问者则将某算法针对此节点执行。

2.角色：
抽象访问者角色（Vistor）:声明一个或多个访问操作，使得所有具体访问者必须实现的接口。
具体访问者角色（ConcreteVistor）：实现抽象访问者角色中所有声明的接口。
抽象节点角色（Element）：声明一个接受操作，接受一个访问者对象作为参数。
具体节点角色（ConcreteElement）：实现抽象元素所规定的接受操作。
结构对象角色（ObjectStructure）：节点的容器，可以包含多个不同类或接口的容器。

访问者模式中具体访问者的数目和具体节点的数目没有任何关系

3.使用场景：
如果系统有比较稳定的数据结构，而又有易于变化的算法时，此时可以考虑使用访问者模式。因为访问者模式使得算法操作的添加比较容易。
如果一组类中，存在着相似的操作，为了避免出现大量重复的代码，可以考虑把重复的操作封装到访问者中。（当然也可以考虑使用抽象类了）
如果一个对象存在着一些与本身对象不相干，或关系比较弱的操作时，为了避免操作污染这个对象，则可以考虑把这些操作封装到访问者对象中。

4.优缺点：

优点：
访问者模式使得添加新的操作变得容易。如果一些操作依赖于一个复杂的结构对象的话，那么一般而言，添加新的操作会变得很复杂。而使用访问者模式，增加新的操作就意味着添加一个新的访问者类。
因此，使得添加新的操作变得容易。
访问者模式使得有关的行为操作集中到一个访问者对象中，而不是分散到一个个的元素类中。这点类似与"中介者模式"。
访问者模式可以访问属于不同的等级结构的成员对象，而迭代只能访问属于同一个等级结构的成员对象。

缺点：
增加新的元素类变得困难。每增加一个新的元素意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中添加相应的具体操作。

参考：https://www.cnblogs.com/zhili/p/VistorPattern.html