ThreadPool

参考链接：
https://blog.csdn.net/SmillCool/article/details/127221960
https://www.cnblogs.com/cdaniu/p/15782290.html

一：特点
ThreadPool 是一个静态类

1.线程池可以看作一个容纳线程的容器，一个应用程序最多有一个线程池，在首次向线程池排入工作函数时自动创建
2.线程池可以设置最小线程数量和最大线程数量
3.可以复用线程，避免重复的销毁和创建
4.不能控制线程的调用和释放
5.默认为后台线程（即 IsBackground=true）
6.优先级为ThreadPriority.Normal
7.每个线程都使用默认的堆栈大小

二：线程池中线程增加减少方式

1.线程池被创建后或者任务数量小于最小值时，运行最小数量的空线程
2.当任务请求数量超过最小值，会在等待一段时间（大约500毫秒）后创建新的线程去执行工作函数
3.当任务请求数量超过最大值，不再创建新的线程，会等待线程池中的某个线程结束后然后执行等待中的任务
4.当任务逐步完成小于最大值时，线程在空闲一段时间后（两分钟）后被释放并且回收相关资源

三：工作者线程和I/O线程
IOCP:输入输出完成端口（Input/Output Completion Port，IOCP）

1.工作者线程(辅助线程)：

用来完成一些计算的任务，在任务执行的过程中，需要CPU不间断地处理，所以，在工作者线程的执行过程中，CPU和线程的资源是充分利用的。
.NET中的术语工作者线程指的是任何线程而不是仅仅主线程。“工作者”的意思表示任何内容，包括等待IO端口完成，线程池会预先缓存一些工作者线程，因为创建线程的代价比较昂贵。

2.I/O线程：

主要用来完成输入和输出的工作，在这种情况下，计算机需要I/O设备完成输入和输出的任务。
在处理过程中，CPU是不需要参与处理过程的，此时正在运行的线程将处于等待状态，只有等任务完成后才会有事可做，这样就造成线程资源浪费的问题。为了解决这样的问题，可以通过线程池来解决这样的问题，让线程池来管理线程。

.NET中的一些API方法，通过APM（异步编程模式），内部实现了ThreadPool.BindHandle方法。BeginXXX方法将用户的回调委托送到某个设备驱动程序，然后返回线程池。
当做完成后，OS会通过IOCP提醒CLR工作已经完成，当接收到通知后，I/O线程会醒来并且运行用户的回调。
所以工作线程由开发人员调用，I/O线程由CLR调用。所以通常情况下，开发者并不会直接用到它。

因此可以认为，工作者线程和I/O线程没有区别，它们都是普通的线程，但是CLR线程池中区分它们的目的是为了避免线程都去处理I/O回调而被耗尽，从而引发死锁。（设想，所有的工作者线程每一个都去等待I/O异步完成。）

开发人员需要关注的是确保I/O线程返回到线程池，I/O回调代码应该做尽量小的工作，并尽快返回到线程池。如果回调代码中的工作很多的话，应该考虑把工作拆分到一个工作者线程中去。否则，应用程序的风险是CLR线程池中保留I/O线程去做了工作者线程的活，可能导致死锁。

四：队列

1.线程池的全局队列(global Queue)：

当调用ThreadPool.QueueUserWorkItem()添加工作项时，该工作项会被添加到线程池的全局队列中。
线程池中的空闲线程以FIFO（First in, First out先进的数据先出 ，后进的数据后出）的顺序将工作项从全局队列中取出并执行，但并不能保证按某个指定的顺序完成。

线程的全局队列是共享资源，所以内部会实现一个锁机制。当一个任务内部会创建很多子任务时，并且这些子任务完成得非常快，就会造成频繁的进入全局队列和移出全局队列，从而降低应用程序的性能。基于此原因，线程池引擎为每个线程引入了局部队列。

2.线程的局部队列（local Queue）

局部队列“通常”以LIFO的顺序抽取任务并执行，而不是像全局队列那样使用FIFO顺序。LIFO顺序有利于数据局部性，能够在牺牲一些公平性的情况下提升性能。
数据局部性的意思是：运行最后一个到达的任务所需的数据都还在任何一个级别的CPU高速缓存中可用。由于数据在高速缓存中仍然是“热的”，因此立即执行最后一个任务可能会获得性能提升。

两个性能优势：任务内联化(task inlining)和工作窃取机制。

1)   任务内联化(task inlining)----活用顶层任务工作线程
     
	 static void Main(string[] args)
{
    Task headTask= new Task(() =&gt;
    {
        DoSomeWork(null);
    });
    headTask.Start();
    Console.Read();
}

private static void DoSomeWork(object obj)
{
    Console.WriteLine("任务headTask运行在线程“{0}”上",
        Thread.CurrentThread.ManagedThreadId);
 
    var taskTop = new Task(() =&gt;
    {
        Thread.Sleep(500);
        Console.WriteLine("任务taskTop运行在线程“{0}”上",
            Thread.CurrentThread.ManagedThreadId);
    });
    var taskCenter = new Task(() =&gt;
    {
        Thread.Sleep(500);
        Console.WriteLine("任务taskCenter运行在线程“{0}”上",
            Thread.CurrentThread.ManagedThreadId);
    });
    var taskBottom = new Task(() =&gt;
    {
        Thread.Sleep(500);
        Console.WriteLine("任务taskBottom运行在线程“{0}”上",
            Thread.CurrentThread.ManagedThreadId);
    });
    taskTop.Start();
    taskCenter.Start();
    taskBottom.Start();
    Task.WaitAll(new Task[] { taskTop, taskCenter, taskBottom });
}

这个示例，我们从Main方法主线程中创建了一个headTask顶层任务并开启。在headTask任务中又创建了三个嵌套任务并最后WaitAll() 这三个嵌套任务执行完成(嵌套任务安排在局部队列)。此时出现的情况就是headTask任务的线程被阻塞，而“任务内联化”技术会使用阻塞的headTask的线程去执行局部队列中的任务。因为减少了对额外线程需求，从而提升了程序性能。

2)  工作窃取机制----活用空闲工作线程

当一个工作线程的局部队列中有很多工作项正在等待时，而存在一些线程却保持空闲，这样会导致CPU资源的浪费。此时任务调度器（TaskScheduler）会让空闲的工作线程进入忙碌线程的局部队列中窃取一个等待的任务，并且执行这个任务。

由于局部队列为我们带来了性能提升，所以，我们应尽可能地使用TPL（Task Parallel Library）提供的服务，而不是直接使用ThreadPool的方法。

五：方法

由于饥饿和死锁的问题存在，所以不建议使用GetMaxThreads、SetMaxThreads、GetMinThreads、SetMinThreads、GetAvailableThreads

1.GetMaxThreads(out Int32,out Int32)
检索可以同时处于活动状态的线程池请求的数目。 所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。

参数1： 工作线程
参数2: I/O线程

2.GetMinThreads(out Int32,out Int32)  
发出新的请求时，在切换到管理线程创建和销毁的算法之前检索线程池按需创建的线程的最小数量。

参数1： 工作线程
参数2: I/O线程

3.QueueUserWorkItem(WaitCallback)    
将方法排入队列以便执行。 此方法在有线程池线程变得可用时执行。

参数1： public delegate void WaitCallback(object state);

4.QueueUserWorkItem(WaitCallback, Object)    
将方法排入队列以便执行，并指定包含该方法所用数据的对象。 此方法在有线程池线程变得可用时执行。

参数1： public delegate void WaitCallback(object state);
参数2： callBack所使用的参数装箱成object

5.RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int32, Boolean)    
注册一个等待 WaitHandle 的委托，并指定一个 32 位有符号整数来表示超时值（以毫秒为单位）。

参数1： EventWaitHandle ;

参数2： public delegate void WaitOrTimerCallback(object state, bool timedOut);
		参数1： 外部传递过来的参数
		参数2： 是否是超时

参数3： 参数2的第一个参数

参数4： 超时时间  
		如果设置成-1 参数2只在接收到信号后运行
        如果设置成其他值 参数2在超时和接收到信号后运行

参数5： 是否循环调用 
		false 第一次运行结束后不再等待运行
        true 每次完成后重记倒计时，直到注销等待

6.SetMaxThreads(Int32, Int32)    
设置可以同时处于活动状态的线程池的请求数目。 所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。

参数1： 工作线程
参数2: I/O线程

7.SetMinThreads(Int32, Int32)    
发出新的请求时，在切换到管理线程创建和销毁的算法之前设置线程池按需创建的线程的最小数量。

参数1: 工作线程
参数2: I/O线程

8.BindHandle(SafeHandle)    
将操作系统句柄绑定到 ThreadPool。

9.GetAvailableThreads(Int32, Int32)    
检索由 GetMaxThreads(Int32, Int32) 方法返回的最大线程池线程数和当前活动线程数之间的差值。

10.UnsafeQueueNativeOverlapped(NativeOverlapped)    
将重叠的 I/O 操作排队以便执行。

11.UnsafeQueueUserWorkItem(WaitCallback, Object)    
将指定的委托排队到线程池，但不会将调用堆栈传播到辅助线程。

12.UnsafeRegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int32, Boolean)    
注册一个等待 WaitHandle 的委托，并使用一个 32 位带符号整数来表示超时时间（以毫秒为单位）。 此方法不将调用堆栈传播到辅助线程。

六：线程池的应用范围
在以下几种情况下，适合于使用线程池线程：

（1）不需要前台执行的线程。
（2）不需要在使用线程具有特定的优先级。
（3）线程的执行时间不易过长，否则会使线程阻塞。由于线程池具有最大线程数限制，因此大量阻塞的线程池线程可能会阻止任务启动。
（4）不需要将线程放入单线程单元。所有 ThreadPool 线程均不处于多线程单元中。
（5）不需要具有与线程关联的稳定标识，或使某一线程专用于某一任务。
（6）一种是在应用程序中，线程把大部分的时间花费在等待状态，等待某个事件发生，然后才能给予响应，这一般使用ThreadPool（线程池）来解决
（7）一种情况是在线程平时都处于休眠状态，只是周期性地被唤醒，这一般使用Timer（定时器）来解决。

七：总结

1、.net 会为每个进程生成一个线程池。线程池的初始值线程数是cpu逻辑内核数。
后面连续建线程要每间隔500ms新建一个线程。即使突然并发大量任务也是按这个进度来新建线程。
2、可以通过设置min thread(默认等于cpu内核数）提高线程池一开始的线程数，从而提高并发数。后面连续建线程要每间隔500ms新建一个线程。
3、本地队列：线程池中的每一个线程都会绑定一个 ThreadPoolWorkQueueThreadLocals 实例，在 workStealingQueue 这个字段上保存着本地队列。
4、全局队列：每个进程只有一个全局队列， 是由 ThreadPoolWorkQueue 维护的，同时它也是整个队列系统的入口，直接被 ThreadPool 所引用。
5、在线程池线程A中生成的任务，会安排入当前线程A的任务队列。
6、当前线程池的线程A的任务队列已经执行完成，如果全局任务队列也没有任务了，就会去查看其他线程B的任务队列，如果其他线程B的任务队列还有很对没完成的，当前线程A就会偷它B的任务执行。
7、线程池使用IO模型有两种：IOCP I/O模型和verlapped I/O模型。
8、线程池将自己的线程划分工作者线程(辅助线程)和I/O线程。前者用于执行普通的操作，后者专用于异步IO，比如文件和网络请求，注意，分类并不说明两种线程本身有差别，内部依然是一样的。

1、.NET框架为每一个进程提供了一个线程池，每当您启动线程时，都会花费几百微秒来组织诸如新的私有局部变量堆栈之类的东西。
2、只有全局一个队列和n本地线程任务队列，无法取消任务，无法限制任务执行速度等等
3、当一个等待操作完成时，线程池中的一个辅助线程就会执行对应的回调函数
4、线程池中的线程由系统进行管理，程序员不需要费力于线程管理，可以集中精力处理应用程序任务。
5、线程池线程都是后台线程。每个线程都使用默认堆栈大小1MB，以默认的优先级运行，并处于多线程单元中，您可以随意更改池线程的优先级，当释放回池时，它将恢复正常。线程池通过共享和回收线程来减少这些开销，从而允许在非常精细的级别应用多线程，而不会降低性能。
6、如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间之后创建另一个辅助线程。
7、但线程的数目永远不会超过最大值。超过最大值的其他线程可以排队，但它们要等到其他线程完成后才启动。
8、如果某个线程在托管代码中空闲（如正在等待某个事件），则线程池将插入另一个辅助线程来使所有处理器保持繁忙。
9、一种是用于处理CPU密集型逻辑的工作线程，即它主要使用CPU来执行其逻辑，如任何计算等，另一种是I / O线程，这些线程用于执行I / O请求或耗时的请求，例如读/写到文件系统， 调用数据库或调用任何第三方 API/请求。
10、线程池不保证全局队列工作项的处理顺序
11、如果工作项完成的时间太长（具体多长没有正式公布）线程池会创建更多的工作者线程，如果工作项完成速度开始变快，工作者线程会被销毁，线程池从其池中的一个线程开始。分配任务时，池管理器会"注入"新线程以处理额外的并发工作负载，最高可达最大限制。在足够长的不活动时间后，如果池管理器怀疑这样做会带来更好的吞吐量，则池管理器可能会"停用"线程。
12、如果全局队列也为空，工作者线程会进入睡眠状态等待事情的发生，如果睡眠了太长时间，他会自己醒来并销毁至深允许系统回收线程使用的资源
13、最好是将线程池看成一个黑盒，不要拿单个应用程序去衡量它的性能，因为它不是针对某个单独应用程序而设计的。线程池内部会更改它的管理线程的方式，所以大多应用程序的性能会变的越来越好
