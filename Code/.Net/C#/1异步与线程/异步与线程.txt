异步与线程：
https://www.cnblogs.com/leslies2/archive/2012/02/07/2310495.html
https://www.cnblogs.com/leslies2/archive/2012/02/08/2320914.html

https://blog.csdn.net/smillcool/category_12034207.html

https://www.cnblogs.com/GaoUpUp/p/17187804.html

https://www.cnblogs.com/cdaniu/p/15845424.html
https://www.cnblogs.com/cdaniu/p/15782290.html

一.进程

1.定义
狭义定义：进程是正在运行的程序的实例。
广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。

2.概念
进程的概念主要有两点：

第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。
文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。

第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。

二、线程：

1.定义
是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

进程作为操作系统执行程序的基本单位，拥有应用程序的资源，进程包含线程，进程的资源被线程共享，线程不拥有资源。进程启动时，公共语言运行时将自动创建单个前台线程以执行应用程序代码。除了此主前台线程，进程还可以创建一个或多个线程来执行与进程关联的程序代码的一部分。 这些线程可以在前台或后台执行。

2.组成
线程主要是由cpu寄存器  调用栈  线程本地存储器（TLS） 组成

cpu寄存器：主要记录当前执行线程的状态
调用栈：主要用来维护线程所调用的内存和数据
TLS：用来存放线程的状态信息

3.创建
通过Thread类新建线程默认为前台线程。当所有前台线程关闭时，所有的后台线程也会被直接终止，不会抛出异常。由于线程的执行顺序和程序的执行情况不可预知，所以使用挂起和唤醒容易发生死锁的情况，在实际应用中应该尽量少用。

前台线程：主程序必须等待线程执行完毕后才可退出程序。Thread默认为前台线程，也可以设置为后台线程。
后台线程：主程序执行完毕后就退出，不管线程是否执行完毕。ThreadPool默认为后台线程。
线程消耗：开启一个新线程，线程不做任何操作，都要消耗1M左右的内存。

4.实现
在单核处理器的电脑中：
多线程的实现是通过cpu在完成一个时间切片之后在活动的线程间进行切换执行来完成的，由于cup运行速度快，所以看上去是同一时刻执行了多个操作，实际同一时刻只有一个线程在处理。

在多核的电脑中：
多线程被实现成混合时间片和真实的并发——不同的线程在不同的CPU上运行。由于操作系统的需要服务自己的线程，以及一些其他的应用程序。这几乎可以肯定仍然会出现一些时间切片。

三.多线程的优缺点及使用场景

使用多线程可以提高CPU的利用率。在多线程程序中，一个线程必须等待的时候，CPU可以运行其它的线程而不是等待，这样就大大提高了程序的效率。线程也是程序，所以线程需要占用内存，线程越多占用内存也越多； 

多线程需要协调和管理，所以需要CPU时间跟踪线程； 线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题；线程太多会导致控制太复杂，最终可能造成很多Bug。拥有多线程本身并不复杂，复杂是的线程的交互作用，这带来了无论是否交互是否是有意的，都会带来较长的开发周期，以及带来间歇性和非重复性的Bug。因此，要么多线程的交互设计简单一些，要么就根本不使用多线程。

当用户频繁地分配和切换线程时，多线程会带来增加资源和CPU的开销。在某些情况下，太多的I/O操作是非常棘手的，当只有一个或两个工作线程要比有较多的线程在相同时间执行任务块的多。

使用多线程的任务应具有并发性，即任务可以拆分为多个子任务，并发执行。只有在CPU是性能瓶颈的情况下，多线程才能实现提升性能的目的。如一段程序，瓶颈在于IO操作，即使把这个程序拆分到2个线程中执行，也是无法提升性能的，另外，CPU必须是多核的。

四、Thread、ThreadPool、Task对比

1.Thread与ThreadPool
Thread默认为前台线程，主程序必须等线程跑完才会关闭，而Threadpool相反。
ThreadPool是Thread基础上的一个线程池，目的是减少频繁创建线程的开销,不过在任务多的时候全局队列会存在竞争而消耗资源。
线程很贵，要开新的stack，要增加CPU上下文切换，所以ThreadPool适合频繁、短期执行的小操作。调度算法是自适应的，会根据程序执行的模式调整配置，通常不需要自己调度线程。

2.Task
Task 类表示以异步方式执行的单个操作。Task 是基于 Thread 的，是比较高层级的封装，Task 最终还是需要 Thread 来执行。
Task的背后的实现也是使用了线程池线程，但它的性能优于ThreadPoll,因为它使用的不是线程池的全局队列，而是使用的本地队列，使线程之间的资源竞争减少。
同时Task提供了丰富的API来管理线程、控制。但是相对前面的两种耗内存，Task依赖于CPU对于多核的CPU性能远超前两者，单核的CPU三者的性能没什么差别。

3.异步执行：Task 支持异步执行，而 Thread 不支持。这意味着，在使用 Task 时，可以通过 await 和 async关键字轻松实现异步编程，而 Thread 则需要手动管理线程的启动和等待。

4.异常处理：Task 提供了更好的异常处理机制，可以将异常传递给调用方，而 Thread 则需要在每个线程中处理异常。

5.任务调度器：Task 提供了任务调度器（TaskScheduler），可以控制任务的并发性和调度方式，而 Thread 则没有这个功能。

6.返回值：Task 可以有返回值，而 Thread 没有。这是因为 Task 是基于 TPL 实现的，可以利用 .NET框架提供的并发编程模型来实现任务之间的依赖和调度。
