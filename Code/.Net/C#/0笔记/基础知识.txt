一、.Net 
.net FrameWork框架是.Net平台中不可缺少的一部分，它提供了一个稳定的运行环境来保证基于.Net平台开发的各种应用能够正常的运转

二、C#(Sharp)
一种编程语言,可以开发基于.Net平台的应用

三、.net都能干什么
1）桌面应用程序(winform应用程序)
2）Internet应用程序	.net开发的Internet应用程序叫ASP.net应用程序
3）手机开发		wp8
4）Unity 3D游戏开发或虚拟现实

四、两种交互模式
1）C/S(Client/Server)，客户端需要安装专用的客户端软件
2）B/S(Browser/Server)，客户机上只要安装一个浏览器 

五、VS（visual studio）
1）启动：Win+R-devenv
2）VS的各个组成部分，解决方案包含项目，项目包含类
3）类的各个组成部分：引用命名空间(using system)-项目名称(namespace)-Rrogram类(class)-方法或函数(Static Void Main) 

六、后缀
.sln(solution)：解决方案文件，包含着整个解决项目的信息，可以双击运行 
.csproj(Csharp Project)：项目文件，包含着此项目的信息，可以双击运行
.cs(class)结尾的为类文件，可以直接用记事本打开看代码

七、变量类型与使用规则
1）数值：
int			整数；
double		小数类型，也能存整数；
2）非数值：
string			字符串，双引号；
char			字符类型，一个字符，单引号；
decimal			加后缀m；
bool类型(布尔)	bool类型的值只有两个，True和False。
const			常量，声明常量的语法：const 变量 变量名 =值；

变量的使用规则
1）使用变量，要先声明或定义，再赋值，再使用
2）变量的作用为存储数据，变量必须以字母、下划线_或@开头，后面可以跟任意字母、数字、下划线_
3）变量不要与关键字重复，蓝色字体是C#系统中的关键字
4）变量的命名规范
Camel骆驼命名规范，变量中的首个单词的首字母小写，其余单词首字母大写，多用于给变量或字段命名
Pascal帕斯卡语言，要求每个单词首字母大写，其余字母小写，多用于给类或函数命名

八、语法错误和异常
异常：语法没有错误，在程序运行期间，由于某些原因程序不能再正常运行
红色波浪线：语法错误；
绿色波浪线：警告线，语法没错误，有可能出现错误

九、符号

1、赋值运算符=
=赋值运算符；表示把等式右边的值赋给等式左边的变量
由=连接的表达式，称之为赋值表达式
每个表达式都可以求出一个定值，对于赋值表达式，等号左边的变量的值，就是整个赋值表达式的值

2、+的使用
1）相加，两边都为数值时起到相加的作用；
2）连接，两边有一边为字符串时，起到连接的作用

3、占位符{}
占位符大括号{}，从0开始，挖了几个坑就应该填几个坑；
占位符按照挖坑顺序输出，多填了，没效果，少填了，出现异常；

4、转义符的使用
转义符就是\+一个特殊的字符，组成了一个具有特殊意义的字符 ；
1）\n换行，console控制台可使用，window系统不认识\n，用\r\n代替 
2）\"表示一个英文半角的双引号 
3）\t=一个Tab键的空格 
4）\b=backspace，放到字符串的两端没有效果
5）\\表示一个\

5、@的使用
1）取消\在字符串中的转义作用，使其单纯的表示一个\；
2）将字符串按照编辑的原格式输出 

6、算数运算符：
1）+加，-减，*乘，/除，%(取余数 取模)
2）++加加，分为前++，和后++，最终的结果都是给变量加1，区别体现在表达式中，
如果是前++，先给变量加1，再参与表达式的运算；
如果是后++，则先参与表达式的运算，在给变量加1；
3）--减减，同上
对于像++和--这种只需要一个操作数就能完成运算的运算符，称之为一元运算符；
对于像加减乘除这种需要两个及以上的操作数才能完成的运算符，称之为二元运算符；
一元运算符的优先级高于二元运算符。

7、复合赋值运算符：
+=	number+=20 == number=number+20
-=
*=
/=
%=

8、关系运算符
用来描述两个事物之间的关系。
由关系运算符连接的表达式称之为关系表达式，关系表达式的结果是布尔类型。
>	大于
<	小于
>=	大于等于	
<=	小于等于
==	等于
!=	不等于

9、逻辑运算符
&&	逻辑与
||	逻辑或
！	逻辑非
逻辑与的优先级高于逻辑或。
由逻辑运算符连接的表达式称之为逻辑表达式。
逻辑运算符两边放的一般都是关系表达式或bool类型的值。
逻辑表达式的结果也是bool类型。

十、类型转换

1、显示类型转换和隐式类型转换
1）自动类型转换，或者称之为隐式类型转换
（1）两种类型兼容
   例如：int和double兼容(都是数字类型)
（2）目标类型大于源类型 
   double>int，小的转大的
2）显示类型转换，或者称之为强制类型转换
（1）两种类型兼容 	int---double
（2）大的转小的	double-->int
语法：(待转换的类型)要转换的值；
double d = 303.6;
int n =(int)d;

2、Convert类型转换
如果两个类型的变量不兼容，比如string和double，可以使用convert类型转换进行转换
看起来能转的才能转，看起来根本就转不了的就不能转。
string a ="123";
double b = convert.todouble(a);

3、类型转换int.tryparse
int number;
int.TryParse("string",out number)
尝试转换，不成功的话，返回number;
convert.toint32=int.Parse;int.Parse就是convert调用的底层程序

4、string类型转换
所有的类型都可以转换成string类型，调用to string转换。
double n1 =3.14;
string s=n1.ToString();

十一、表达式
对于表达式，表达式左边是变量，表达式右边的数值叫操作数，符号叫运算符；
如果一个操作数是double类型，则整个表达式提升为double类型
int n1 = 10;
int n2 = 3;
double d = n1/n2;
结果d=3
想要得到小数，要改写为double d = n1*1.0/n2，或double n1 =10
如果要设定保留几位小数可以用占位符操作
console.writeline("{0:0.00}",d);

十二、程序结构
1）顺序结构：程序从main函数进入，一行一行执行。
2）分支结构：if，　 if-else
3）选择结构：if else-if  ， switch-case
4）循环结构：while ， do-while，  for，  foreach

1、while循环
while循环
特点：先判断再执行，有可能一次都不执行
while(循环条件)
{
      循环体；
}
执行过程：程序运行到while处，首先判断循环条件是否成立，
如果成立，执行循环体，执行一遍循环体后，再次判断循环条件，
直到不成立，跳出while循环。
在while循环中，一般会有那么一行代码使循环条件不再成立；
如果没有，也就是循环条件永远都成立，我们称这种循环为死循环；
最简单的最常用的死循环：
while(true)
{
}

2、do while循环
do
{
   循环体；
}
while(判断条件)；
执行过程：首先执行do中的循环体，执行完成后，再去判断循环条件；
如果成立，继续执行循环体，如果不成立，跳出do-while循环。
特点：先循环，再判断，至少执行一次。

3、for循环
for(表达式1，表达式2，表达式3)
{
  循环体；
}
表达式1一般为声明循环变量；记录循环的次数(int i=0);
表达式2一般为循环条件(i<10)；
表达式3一般为改变循环条件的代码，使循环条件不再成立(i++);

4、三元表达式
if-else的简化写
表达式结果=表达式1?表达式2:表达式3；
表达式一般为一个关系表达式；
如果表达式1的值为TRUE，那么表达式2的值就是整个三元表达式的值，
如果表达式1的值为FALSE，那么表达式3的值就是整个三元表达式的值；
表达式2和表达式3的结果类型必须一致，并且也必须跟整个三元表达式的结果类型一致。

十三、异常捕获
try-catch
try
{
  可能会出现异常的代码；
}
catch
{
  出现异常后要执行的代码；
}
执行过程：如果try中的代码没有出现异常，catch中的代码不执行；
如果try中的代码出现异常，不再继续向下执行，马上跳到catch中。
try和catch必须紧密相连，中间不允许有其他代码。

十四、变量的作用域
变量的作用域就是你能够使用到这个变量的范围。
变量的作用域从声明这个变量的{开始，到对应的}结束，超出作用域不能使用此变量。

十五、关键字
1、break
1）可以跳出Switch-case结构
2）可以跳出当前循环
break一般不单独使用，而是跟着if判断一起使用，表示如果满足某些条件的时候，就不再循环了。

2、continue
立刻结束本次循环，判断循环条件，如果成立，继续循环，不成立，跳出循环。

3、return：
1）在方法中返回要返回的值；
2）立即结束本次方法。

4、new关键字
person zs =new person();
new做了三件事
1）在内存中开辟一块空间
2）在开辟的空间中创建对象
3）调用对象的构造函数初始化对象

5、this关键字
1）代表当前类的对象。
2）在类当中显示的调用类的构造函数。 :this

十六、随机数
Random r=new Random();
int number=r.Next(1,11); 产生1-10的数字  左闭右开

十七、枚举
语法：
public enum 枚举名  （public可省略）
{
值1,
值2,
值3,
........
}
enum:关键字，声明枚举的关键字。
枚举名:要符合pascal命名规范。

将枚举声明到命名空间的下面，类的外面，表示这个命名空间下，所有的类都可以使用这个枚举。
枚举就是一个简单的变量类型，int、double等，只是枚举声明、赋值、使用的方式跟普通的变量类型不同。

枚举类型默认可以跟int类型互相转换；枚举类型和int类型是互相兼容的，可以使用强制转换(int)。
当转换一个枚举没有的值的时候，不会抛异常，而是直接将数字显示出来。

枚举转string，调用ToString；要转换的值.tostring()；
string转枚举，(要转换的枚举类型)Enum.parse(typeof(要转换的枚举类型)，要转换的字符串)，E要大写。
如果要转换的字符串是数字，就算枚举中没有，也不会抛异常；
如果要转换的字符串时文本，如果枚举中没有，抛异常。

十八、结构
一次性声明多个变量。
字段可以存多个值，变量只能存一个值。
语法：
public(可省略) struct 结构名
{
  成员；//字段,字段前要加_
}
例如：
public struct Person
{
  public string  _name;
  public int _age;
  public char _gender;
}
变量在程序运行期间只能存储一个值，而字段可以存储多个值。

十九、数组
一次性存储多个想同类型的变量。
语法：
数组类型[] 数组名=new 数组类型 [数组长度(数组名.length)];
如：int[] nums =new int[10];
         int[] numsTwo={1,2,3,4,5,6};
数组的写法：
int [] nums =new int[] {0,1,2,3,4}
数组的长度一旦固定了，就不能再被改变。

二十、函数、方法
1、函数就是将一堆代码进行重用的一种机制。
函数的语法：
public(可省略) static 返回值类型 函数名 （参数列表(可省略)）
{
   方法体
}
参数列表：完成这个方法所必须要提供的条件。如果没有参数，小括号也不可以省略。
方法写好后，如果想要被执行，必须在main函数中调用。

2、方法的重载
概念：方法的重载就是方法的名称相同，但是参数不同。
1）如果参数的个数相同，类型就不能相同；
2）如果参数的类型相同，个数就不能相同。
方法的重载跟返回值没关系。

3、方法的递归
方法自己调用自己。
例：找到一个文件夹中的所有文件。

4、方法中的数组
在方法中改变数组的值，不用ref参数、也不用返回值就可以改变传进方法的数组。

二十一、调用
在main函数中调用test函数，我们管main函数叫做调用者，管test函数叫做被调用者。
如果被调用者想要得到调用者的值；
1）传递参数；
2）声明一个静态字段来模拟全局变量
如果调用者想要的到被调用者的值；
1）返回值 return

不管是形参还是实参，都在内存中开辟空间。

二十二、参数out、ref、params
1）out参数可以在一个方法中返回多个不同类型的值。out参数要求在其方法的内部必须为其赋值。

2）ref参数能够将一个变量带入一个方法中进行改变，改变完成后，再将改变后的值带出方法。
ref参数要求在方法外必须赋值，方法内可以不赋值。

3）params可变参数
将实参列表中跟可变参数数组类型一致的元素都当做数组的元素去处理。
params可变参数必须是形参列表中的最后一个元素。

二十三、面向对象
面向过程-----> 面向对象
面向过程：面向的是完成这件事儿的过程，强调的是完成这件事儿的动作。
面向对象：找个对象帮你做事儿。
我们在代码中描述一个对象，通过描述这个对象的属性和方法
对象必须是看得见摸得着的

我们把具有相同属性和方法的对象进行进一步的封装，抽象出来”类“这个概念。
类就是一个模子，确定了对象应该具有的属性和方法。
对象是根据类创建出来的。
类就是一个盖楼的图纸  对象就是盖出来的楼。

二十四、类
语法：
public(可省略) class 类名
{
  字段；(field)
  属性；(property)
  方法；(method)
}

写好了一个类之后，我们要创建这个类的对象；
我们管创建这个类的对象这个过程叫做类的实例化；
使用关键字 New.
this :表示当前这个类的对象
类是不占内存的，对象占。

对象的初始化
当我们创建好一个类的对象后，需要给这个对象的每个属性去赋值。
这个过程叫做对象的初始化。

二十五、属性
属性的作用就是保护字段，对字段的赋值和取值进行限定。
属性的本质就是两个方法，get()，set()。
既有get()也有set()我们称之为可读可写属性。
只有get()没有set()我们称之为只读属性
没有get()只有set()我们称之为只写属性

自动属性
不需要声明字段，get和set没有方法体的叫做自动属性，会自动声明一个字段。

二十六、静态和非静态的区别
1）在非静态类中，既可以有实例成员(非静态)，也可以有静态成员。
       在静态类中，只可以有静态成员，不允许有实例成员。
2）在调用实例成员的时候，需要使用对象名.实例成员；
       在调用静态成员的时候，需要使用类名.静态成员。

总结：静态成员必须使用类名去调用，而实例成员必须使用对象名去调用。

静态函数中，只能访问静态成员，不能访问实例成员。
实例函数中，既能访问静态成员，也可以访问实例成员。

使用：
1）如果你想要你的类当做一个"工具类"去使用，这个时候可以考虑将类写成静态的。
2）静态在整个项目中资源共享。
静态类占内存。
堆   栈     静态存储区域

释放资源。  GC   Garbage Collection 垃圾回收器

二十七、构造函数
作用：帮助我们初始化对象(给对象中的属性依次赋值)
构造函数是一个特殊的方法：
1）构造函数没有返回值，连void也不能写
2）构造函数的名称必须跟类名一致
创建对象的时候会执行构造函数。
构造函数是可以有重载的。
类当中会有一个默认的无参数的构造函数。

二十八、析构函数
程序结束的时候才会执行。
~类名()
{
}

二十九、引用命名空间
可以解决类的重名问题。可以看做是类的文件夹。
如果在这个项目中没有这个类的命名空间，需要我们手动导入这个类的命名空间。
1）鼠标去点
2）Alt+shift+F10
3）记住命名空间，手动的去引用

在一个项目中引用另一个项目的类
在一个项目中引用另一个项目的类
1）添加引用
2）引用命名空间

三十、值类型和引用类型
区别：
1）值类型和引用类型在内存上存储的地方不一样。
2）在传递值类型和引用类型的时候，传递的方式不一样
值类型称之为值传递，引用类型称之为引用传递。

值传递和引用传递
值类型在复制的时候，传递的是这个这个值本身；
引用类型复制的时候，传递的是这个对象的引用。
string比较特殊，有不可变性，复制的时候会再开辟空间。

值类型：Int Double  Char Decimal Bool Enum Struct 
引用类型：String 数组 集合 自定义类 Object 接口
存储：
值类型的值存储在栈中；
引用类型的值存储在堆中。

三十一、字符串
1、字符串的不可变性
当你给字符串重新赋值的时候，老值并没有销毁，而是重新开辟一块空间存储新值。
当程序结束后，GC（Garbage Collection 垃圾回收器）扫描整个内存，如果发现有的空间没有被指向，则立即把它销毁。

2、我们可以将字符串看做是char类型的一个只读数组。
string s="abcd"
char[] chs=s.ToCharArray();将字符串转为char数组；
s = new string(char[] chs);能够将一个char数组转成一个字符串。

3、字符串提供的各种方法
string s;
1）s.length：字符串的字符个数。
2）s.ToUpper(): 将字符串转换成大写形式；
3）s.ToLower():  将字符串转换成小写形式；
4）s.Equals(lessontwo,StringComparison.OrdinalIgnoreCase):  比较两个字符串，可以忽略大小写；
5)、Split()：分割字符串，返回字符串类型的数组。
6)、Substring()：截取字符串。在截取的时候包含要截取的那个位置。
7)、IndexOf():判断某个字符串在字符串中第一次出现的位置，如果没有返回-1、值类型和引用类型在内存上存储的地方不一样。
8)、LastIndexOf()：判断某个字符串在字符串中最后一次出现的位置，如果没有同样返回-1
9)、StartsWith():判断以....开始
10)、EndsWith():判断以...结束
11)、Replace():将字符串中某个字符串替换成一个新的字符串
12)、Contains():判断某个字符串是否包含指定的字符串
13)、Trim():去掉字符串中前后的空格
14)、TrimEnd()：去掉字符串中结尾的空格
15)、TrimStart()：去掉字符串中前面的空格
16)、string.IsNullOrEmpty():判断一个字符串是否为空或者为null
17)、string.Join()：将数组按照指定的字符串连接，返回一个字符串。

三十二、计时器StopWatch
StopWatch sw =new StopWatch();   创建了一个计时器，秒表
sw.Start();		开始计时；
sw.Stop();		结束计时；
sw.Elapsed();		程序执行的时间；

三十三、stringbuilder
StringBuilder  sb=new StringBuilder();
sb.append();    把字符串累加起来
sb.tostring();    转成字符串类型

三十四、继承
我们可能会在一些类中，写一些重复的成员，我们可以将这些重复的成员，
单独的封装到一个类中，作为这些类的父类。
Student、Teacher、Driver  子类  派生类
Person   				  父类  基类
子类继承了父类，那么子类从父类那里继承过来了什么？
首先，子类继承了父类的属性和方法，但是子类并没有继承父类的私有字段。
问题：子类有没有继承父类的构造函数？
答：子类并没有继承父类的构造函数，但是。子类会默认的调用父类无参数的构造函数，
创建父类对象，让子类可以使用父类中的成员。
所以，如果在父类中重新写了一个有参数的构造函数之后，那个无参数的就被干掉了，
子类就调用不到了，所以子类会报错。
解决办法：
1)、在父类中重新写一个无参数的构造函数。
2)、在子类中显示的调用父类的构造函数，使用关键字:base()

继承的特性
1、继承的单根性：一个子类只能有一个父类。
2、继承的传递性

object是所有类的基类。
object是所有类型的父类。

三十五、里氏转换
1）子类可以赋值给父类；
2）如果父类中装的是子类对象，那么可以将这个父类强制转换为子类；

子类对象可以调用父类中的成员，但是父类对象永远都只能调用自己的成员。

三十六、is和as
is：表示类型转换，如果能够转换成功，则返回一个true，否则返回一个false
as：表示类型转换，如果能够转换则返回对应的对象，否则返回一个null

三十七、集合
非泛型：
1、ArrayList集合的长度问题
每次集合中实际包含的元素个数(count)超过了可以包含的元素的个数(capcity)的时候，
集合就会向内存中申请多开辟一倍的空间，来保证集合的长度一直够用。

2、Hastable 键值对集合  字典
在键值对集合当中，我们是根据键去找值的。
键值对对象[键]=值;
*****:键值对集合当中，键必须是唯一的，而值是可以重复的

泛型：
1、泛型集合list
list<int> 集合名=new list<int>();

2、dictionary
dictionary<int,string>  dic=new dictionary<int,string>();
foreach(KeyValuePair<int,string> kv in dic)
{
      console.writeline("{0}------{1}",kv.key,kv.value)
}

三十八、编码格式
产生乱码的原因就是因为你保存这个文件的编码格式跟你打开这个文件的编码格式不一样。
文本文件
拖到txt文件中，还能看得懂的文件就是文本文件。

三十九、Path类、Flie类、Directory

1、File类:
Create
Delete
Move 
Copy
读写数据:
ReadAllBytes()	字节数组--字符串	Encoding.Default.GetString(字节数组)
WriteAllBytes()	字符串--字节数组	Encoding.Default.GetBytes(字符串)

2、Directory 文件夹 目录
File 文件	Path 路径	FileStream 文件流	StreamReader	StreamWriter
Directory静态类	文件夹 目录
Directory.CreatDirectory(路径);				创建文件夹
Directory.Delete(文件夹路径，TRUE(文件夹中由内容也删除));	删除文件夹
Directory.Move(要剪切的文件夹路径，要放到的路径);		剪切文件夹
Directory.GetFiles(指定的文件夹,"*.jpg"(得到含有指定字符的));	指定文件夹下所有文件的全路径，返回string[]
Directory.GetDirectories();				获得指定目录中的所有文件夹的全路径
Directory.Exists();				判断指定的文件夹是否存在，返回bool

四十、绝对路径和相对路径
绝对路径：通过给定的这个路径直接能在我的电脑中找到这个文件。
相对路径：文件相对于应用程序的路径。
结论：
我们在开发中应该去尽量的使用相对路径。


四十一、装箱、拆箱
装箱：把值类型转换为引用类型；
拆箱：把引用类型转换为值类型；
看两种类型是否发生了装箱或者拆箱，要看，这两种类型是否存在继承关系。

四十二、文件流
FIleStream		操作字节的；
StreamReader和StreamWriter	操作字符的；
将创建文件流对象的过程写在using当中，会自动的帮助我们释放流所占用的资源。

四十三、多态
概念：让一个对象能够表现出多种状态（类型）
屏蔽各个子类的差异，写出通用的代码。

实现多态的三种方法：
1、虚方法
步骤：将父类的方法标记为虚方法，使用关键字 virtual，这个函数可以被子类重新写一遍。子类函数加override
2、抽象类
当父类中的函数不知道如何去实现的时候，可以考虑把父类写成抽象类，把方法写成抽象方法。abstract
抽象方法没有方法体，没有{}；
有{}就有方法体，如果{}里没东西，叫做空实现。

1.抽象成员必须标记为abstract,并且不能有任何实现。
2.抽象成员必须在抽象类中。
3.抽象类不能被实例化
4.子类继承抽象类后，必须把父类中的所有抽象成员都重写。
（除非子类也是一个抽象类，则可以不重写）
5.抽象成员的访问修饰符不能是private
6.在抽象类中可以包含实例成员。
并且抽象类的实例成员可以不被子类实现
7.抽象类是有构造函数的。虽然不能被实例化。
8、如果父类的抽象方法中有参数，那么。继承这个抽象父类的子类在重写父类的方法的时候必须传入对应的参数。
如果抽象父类的抽象方法中有返回值，那么子类在重写这个抽象方法的时候 也必须要传入返回值。
======
如果父类中的方法有默认的实现，并且父类需要被实例化，这时可以考虑将父类定义成一个普通类，用虚方法来实现多态。
如果父类中的方法没有默认实现，父类也不需要被实例化，则可以将该类定义为抽象类。

3、接口
public interface I...able
{
   接口成员
}
1）接口就是一种规范、能力。
只要一个类继承了一个接口，就必须实现这个接口中的所有成员。
2）为了多态，接口不能被实例化；
也就是说不能被new，创建对象。
3）接口中的成员不允许添加访问修饰符，默认为public；
4）接口中的成员不能有任何实现，不允许有方法体。（光说不做，只是定义了一组未实现的成员）
5）接口中只能有函数、自动属性、索引器，本质上都是函数。
接口中不允许有字段和构造函数。
6）接口和接口之间可以继承，并且可以多继承。
7）接口不能继承类，接口只能继承接口；类可以继承接口
8）接口的子类必须实现接口中的所有成员。
9）一个类如果继承了另一个类并实现多个接口，在语法上必须把基类写在第一个，接口写在后面。

显示实现接口，解决方法的重名问题；
void iflyable(接口名).fly(方法名)();


四十四、访问修饰符
1）Public
2）Private
3）Protected：受保护的，只能在当前类和该类的子类中访问。
4）Internal：只能在当前程序集中访问。
5）Protected Internal：Protected+Internal

1）修饰类的只能用Public和Internal。
2）可访问性不一致。
子类的访问权限不能高于父类，会暴露父类的成员。

四十五、序列化和反序列化
序列化就是将对象转化为二进制；
反序列化就是将二进制转化为对象；
作用：传输数据。
序列化：
1）将这个类标记为可以被序列化的；
在类的上方标记[serializable]
BinaryForMatter bf=new BinaryForMatter();
bf.Serialize();

四十六、部分类、密封类
部分类：
关键字Partial
本质上还是一个类，一个部分类中声明的成员，另一个都可以使用。

密封类：
关键字Sealed
密封类不可以被其他类继承，但是可以继承其他类。

四十七、guid类
guid.newguid()	创建独一无二的编码，tostring得到数据。

四十八、MDI窗体设计
1）首先确定一个父窗体。将IsMDIContainer设置为true。
MenuStrip菜单栏；
2）创建子窗体，并且设置他们的父窗体；
MDIParent=父窗体；设定父窗体；
layoutMDI(MdiLayout.TileHorizontal/TileVertical)

四十九、SoundPlayer
SoundPlayer sp=new SoundPlayer();
sp.laocation=文件地址；
sp.play();

五十、进程Process

进程：
静态方法；
process[] pros=process.GetProcesses();
process.start("carl");			打开计算器
process.start("mspaint");			打开画图
process.start("notepad");			打开记事本
process.start("iexplore","http://www.baidu.com");	打开网站

ProcessStartInfo psi=new ProcessStartInfo(@"文件路径");
process p=new process();
p.ProcessInfo=psi;
p.start();

五十一、线程
多线程：让计算机同时做多件事情，节约时间。
前台线程：只有所有的前台线程都关闭，才能完成程序关闭；
后台线程：只要所有的前台线程结束，后台线程自动结束；

thread th=new thread();
th.isBackGround=true;	线程默认为前台线程，通过此属性设定是否为后台线程。
th.start();		标记该线程可以被CPU执行的了，具体的执行时间由CPU决定。
在.net下不允许跨线程的访问；
Control.CheckForIllegalCrossThreadCalls = false;		不判断是否跨线程访问；
th.abort();		立即结束线程
静态方法
thread.Sleep();		将线程停止一段时间。

进程和线程的关系：一个进程包括多个线程；

如果线程执行的函数需要参数，其类型必object；

五十二、Socket套接字
英文原意是孔或者插座。在网络中，作为进程通信机制，取后一种意思。
通常也称作套接字，用于描述IP地址和端口，是一个通信链的句柄。（就是两个程序通信用的）

服务器最少有两个socket，一个负责监听的socket（IP 地址和端口号），监听是否有客户端要与服务端的应用程序通信，
当监听socket发现有客户端连进来之后，马上创建一个负责跟客户端通信的socket。
客户端只有一个socket。

TCP：三次握手，安全稳定，效率低；
UDP：效率高，但是不稳定，容易出现数据丢失；

端口号0~65535		65535(十进制)=1111111111111111(16位二进制)
